---
output: html_document
title: "Spatial networks in R with sf and tidygraph"
---

## Introduction

Mobility networks, electrical and telecommunication lines, rivers, these are all examples of spatial networks, that is, organized systems of nodes and edges embedded in space. Most of these networks are associated to a set of coordinates in the 'real' world, therefore to an actual geographical location. 

Even if several approaches have been already developed to deal with graph representations of spatial networks, where a wide set of measures and computations can be developed through basic Graph Theory concepts, the spatial network on itself, loses its geographical properties when converted into a graph. 

Hence, a combination of both the geographical and graph components of such networks are presented on this blogpost.

<!-- Introduce the topic. Why would you want a spatial network... -->

## Existing R packages for spatial networks

Although R was originally designed as a language for statistical computing, an active 'R-spatial' ecosystem has evolved.
Powerful and high performance packages for spatial data analysis have been developed, thanks largely to interfaces to mature C/C++ libraries such as GDAL, GEOS and PROJ, notably in the package [sf](https://github.com/r-spatial/sf) (see [section 1.5 ](https://geocompr.robinlovelace.net/intro.html#the-history-of-r-spatial) of Geocomputation with R for a brief history).
Likewise, a number of packages for graph representation and analysis have been developed, notably [tidygraph](https://github.com/thomasp85/tidygraph), based on lower level libraries such as igraph.

Both sf and tidygraph support the the `tibble` class and the broader 'tidy' approach to 'data science', which involves data processing pipelines, type stability and a convention of representing everything as a data frame (well a `tibble`, which is a data frame with user friendly default settings).
In sf, this means storing spatial vector data as objects of class `sf`, which are essentially the same as a regular data frame (or tibble), but with an additional 'sticky' list column containing a geometry for each feature (row), and attributes such as bounding box and CRS.
Tidygraph is build on top of the widely-used [igraph](https://github.com/igraph/igraph) package, and stores networks in objects of class `tbl_graph`. A `tbl_graph` is an igraph-object, but enables the user to manipulate both the edges and nodes elements as if they were data frames also.

Both sf and tidygraph are relatively new packages (first released on CRAN in 2016 and 2017, respectively).
It is unsurprising, therefore, that they have yet to be combined to allow a hybrid, tibble-based representation of graphs, the nodes of which are embedded in space, i.e. spatial networks.
A number of approaches have been developed for representing spatial networks, and some of these are in packages that have been published on CRAN. [stplanr](https://github.com/ropensci/stplanr), for instance, contains the `SpatialLinesNetwork` class, which works with both [sp](https://github.com/edzer/sp/) (a package for spatial data analysis launched in 2005) and sf packages.
[dodgr](https://github.com/ATFutures/dodgr) is a more recent package that provides analytical tools for spatial networks, with a focus on directed graphs (that can have direction-dependent weights, e.g. representing a one-way street).
Other packages seeking to implement spatial networks in R include [spnetwork](https://github.com/edzer/spnetwork), a package that defined a class system combining sp and igraph, and [sfnetworks](https://github.com/luukvdmeer/sfnetworks), which combines sf and igraph objects using a tidyverse-orientated approach.

This blogpost presents, with help of two examples, a general approach to store spatial networks in a tidy way by combining sf and tidygraph. Along the way, we will see that there is still a way to make this approach clear, convenient and efficient.

## Set-up

The following code chunk will install the packages used in this article:

```{r, eval=FALSE, message=FALSE}
# we'll use remotes to install packages, install it if needs be:
if(!"remotes" %in% installed.packages()) {
  install.packages("remotes")
}

cran_pkgs = c(
  "sf",
  "osmdata",
  "dodgr",
  "stplanr",
  "dplyr",
  "piggyback",
  "tidygraph"
)

github_pkgs = c("luukvdmeer/sfnetworks")

remotes::install_cran(cran_pkgs)
remotes::install_github(github_pkgs)
```

```{r, warning = FALSE, message = FALSE}
library(sf)
library(tidygraph)
library(dplyr)
library(tibble)
library(ggplot2)
```

## From sf to tbl_graph: a step wise approach
...

### Step 1: Load data
As an example, we use the street network of the city center of MÃ¼nster, Germany. It is loaded as an object of class `sf`, and contains only `LINESTRING` geometries, without any additional variables.

```{r, results = FALSE, warning = FALSE, message = FALSE}
piggyback::pb_download('muenster-center.geojson')
muenster_center <- read_sf('muenster-center.geojson')
```

```{r, cache = TRUE}
muenster_center
ggplot(data = muenster_center) + geom_sf()
```

### Step 2: Give each edge an unique index
The edges of the network, are simply the linestrings in the data. Each of them gets an unique index, which can be later be related to their start and end node.

```{r}
edges <- muenster_center %>%
  mutate(edgeID = c(1:n()))

edges
```

### Step 3: Create nodes at the start and end point of each edge
The nodes of the network, are the start and end points of the edges. The locations of these points can be derived by using the `st_coordinates` function in sf. When given a set of linestrings, this function breaks down each of them into the points they are build up. It returns a matrix with the X and Y coordinates of those points, and additionally an integer indicator L1 specifying to which line a point belongs. These integer indicators correspond to the edge indices defined in step 2. That is, if we convert the matrix into a `data.frame` or `tibble`, group the features by the edge index, and only keep the first and last feature of each group, we have the start and end points of the linestrings.

```{r}
nodes <- edges %>%
  st_coordinates() %>%
  as_tibble() %>%
  rename(edgeID = L1) %>%
  group_by(edgeID) %>%
  slice(c(1, n())) %>%
  ungroup() %>%
  mutate(start_end = rep(c('start', 'end'), times = n()/2))

nodes
```

### Step 4: Give each node an unique index
Each of the nodes in the network needs to get an unique index, such that they can be related to the edges. However, we need to take into account that edges can share either startpoints and/or endpoints. Such duplicated points, that have the same X and Y coordinate, are one single node, and should therefore get the same index.

```{r}
node_indices <- nodes %>%
  group_by(X, Y) %>%
  group_indices()

nodes <- nodes %>%
  mutate(nodeID = node_indices)

nodes
```

### Step 5: Combine the node indices with the edges
Now each of the start and endpoints from step has been assigned a node ID in step 4, we can add the node indices to the edges. In other words, we can specify for each edge, in which node it starts, and in which node it ends.

```{r}
source_nodes <- nodes %>%
  filter(start_end == 'start') %>%
  pull(nodeID)

target_nodes <- nodes %>%
  filter(start_end == 'end') %>%
  pull(nodeID)

edges = edges %>%
  mutate(from = source_nodes, to = target_nodes)

edges
```

### Step 6: Remove duplicate nodes
Having added the unique node ID's to the edges data, we don't need the duplicated start and endpoints anymore. After removing them, we end up with a `tibble` in which each row represents a unique, single node. This tibble can be converted into an `sf` object, with `POINT` geometries.

```{r}
nodes <- nodes %>%
  distinct(nodeID, .keep_all = TRUE) %>%
  select(-c(edgeID, start_end)) %>%
  st_as_sf(coords = c('X', 'Y')) %>%
  st_set_crs(st_crs(edges))

nodes
```

### Step 7: Convert to tbl_graph
The first six steps led to one `sf` object with `LINESTRING` geometries, representing the edges of the network, and one `sf` object with `POINT` geometries, representing the nodes of the network. The `tbl_graph` function allows us to convert these two into a `tbl_graph` object. There are two tricky parts in this step that need to be highlighted. One, is that the columns containing the indices of the source and target nodes should either be the first two columns of the `sf` object, or be named 'to' and 'from', respectively. Secondly, inside the `tbl_graph` function, these columns are converted into a two-column matrix. However, an `sf` object has a so-called 'sticky geometry', which means that the geometry column sticks to the attributes whenever specific columns are selected. Therefore, the matrix created inside `tbl_graph` has three columns instead of two, and that causes an error. Therefore, we first need to convert the `sf` object to a regular `data.frame` or `tibble`, before we can construct a `tbl_graph`. In the end, this doesn't matter, since both the nodes and edges will be 'integrated' into an `igraph` structure, and loose their specific `sf` characteristics.

```{r}
graph = tbl_graph(nodes = nodes, edges = as_tibble(edges))

graph
```

## Combining the best of both worlds