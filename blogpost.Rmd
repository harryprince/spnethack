---
output: html_document
title: "Spatial networks in R with sf and tidygraph"
---

The R community can lean on very powerful packages for spatial vector data analysis ([sf](https://github.com/r-spatial/sf)) and network analysis ([tidygraph](https://github.com/thomasp85/tidygraph)), that both support the popular 'tidy' approach to data science. In sf, spatial vector data are stored as objects of class `sf`, which are flat tables with a list column that contains the geometry of the features. Tidygraph is build on top of the widely-used [igraph](https://github.com/igraph/igraph) package, and stores networks in objects of class `tbl_graph`. A `tbl_graph` is an igraph-object, but enables the user to manipulate both the edges and nodes elements as being flat tables.

Despite the existence of sf and tidygraph, R seems to lack a general, modern way to store networks whose nodes are embedded in space, i.e. spatial networks. The [stplanr](https://github.com/ropensci/stplanr) package contains the `SpatialLinesNetwork` class. This, however, is based on [sp](https://github.com/edzer/sp/), a package for spatial data analysis launched in 2005, that is used less since sf entered the stage. The same yields for [spnetwork](https://github.com/edzer/spnetwork), a package that combined sp and igraph. More recently, [dodgr](https://github.com/ATFutures/dodgr) was created. This package provides very fast analytical tools for spatial networks, but deals solely with dual-weighted directed graphs, mainly used for calculating shortest paths in street networks.

This blogpost presents, with help of two examples, a general approach to store spatial networks in a tidy way by combining sf and tidygraph. Along the way, possible improvement points to make this approach more convenient will show up.

## Example 1: Fietstelweek

Fietstelweek is, translated from Dutch, the National Bicycle Count week. It is a crowdsourced initiative to collect data on what routes cyclists take to get from their origins to their destinations. The data were collected between September 14th and 20th in 2015, and between September 19th and 25th in 2016, through a mobile app which makes use of the cellphone GPS to track the trips. Around 50 thousand people participated. The data are available on [bikeprint.nl](http://www.bikeprint.nl/fietstelweek/) for download, and include seperate spatial files for edges and nodes.

To illustrate how such a spatial network could be stored in R, we use the Fietstelweek data for the municipality of Groningen as an example. The data has some flaws in the form of negative node indices in the edges frame, which we need to remove first.

```{r, results = FALSE, message = FALSE, warning = FALSE}
library(piggyback)
library(sf)
library(tidyverse)

pb_download("groningen_edges.gpkg")
pb_download("groningen_nodes.gpkg")

edges <- st_read("groningen_edges.gpkg") %>% 
  filter(SOURCE > 0 & TARGET > 0)
nodes <- st_read("groningen_nodes.gpkg")
```

Each node has a `POINT` geometry and several attributes: a unique ID (`KNOOPNUMME`), the average waiting time at the node (`TIJD`), and the number of routes that passed the node (`AANTAL`). 

```{r}
nodes
```

```{r, message = FALSE, fig.width = 9}
library(tmap)
tmap_mode('view')
qtm(st_geometry(nodes))
```

Each edge has a `MULTILINESTRING` geometry and several attributes: a unique ID (`LINKNUMMER`), the ID's of the source and target nodes, the functional type of the edge (`HIGHWAY`), the average speed, and the number of routes using that edge (`INTENSITEI`).

```{r}
edges
```

```{r, fig.width = 9}
qtm(st_geometry(edges))
```

The `sf` class subclasses a `data.frame`, and the tidygraph package has a specific function to create a `tbl_graph` object from two data frames, where one contains the nodes and the other the edges. That is, we can easily construct a `tbl_graph` from the two `sf` objects that we created above. Regarding the edges data frame, it is important that the columns that specify the ID's of the source an target node are either the first two columns of the data frame, or are named 'to' and 'from', respectively. Both may be inconvenient and even unwanted, but for now, it unfortunately is the only way.

```{r, message = FALSE, warning = FALSE}
edges <- edges %>% select(SOURCE, TARGET, LINKNUMMER, everything())
colnames(edges)
```

```{r, error = TRUE, message = FALSE, warning = FALSE}
library(tidygraph)

graph <- tbl_graph(nodes = nodes, edges = edges)
```

Oops, something seems to go wrong! Inside the tbl_graph function, the first two columns of the edges data frame are converted into a matrix. However, an `sf` object has a so-called 'sticky geometry', which means that the geometry column sticks to the attributes whenever specific columns are selected. Therefore, the matrix created inside tbl_graph has three columns instead of two, and that causes an error. Therefore, we first need to convert the `sf` object to a regular `data.frame` - or, to keep it tidy, a `tibble` - before we can construct a `tbl_graph`.

```{r, error = TRUE}
graph <- tbl_graph(nodes = nodes, edges = as_tibble(edges))
``` 

It seems like the street network of a medium sized city (Groningen has 230.000 inhabitants) is already too large for tidygraph to work with, which seems to be caused by the underlying igraph package. This is very inconvenient, since a lot op spatial network will even be considerably larger than that.

For now, let's take a subset of the original network, just to show how things could work when the memory limit was not there. 

```{r, warning = FALSE}
selection = (st_bbox(edges) + c(15000, 8000, 0, 0)) %>%
  st_as_sfc()

edges = st_intersection(edges, selection)
nodes = nodes %>%
  filter(KNOOPNUMME %in% c(edges$SOURCE, edges$TARGET))
```

```{r, fig.width = 9}
qtm(st_geometry(edges))
```

## Example 2: Australian Electricity Transmission Lines

Another example of a Spatial Network can come from Electricity Transmission Lines (ETL). They are spatial networks since they have coordinates somewhere on Earth. We can take an example from the far edge of it, Australia!

```{r, eval = F}
library(piggyback)
pb_download("etl_aus.geojson")
```

```{r, results = FALSE, message = FALSE, warning = FALSE}
library(sf)
etl_aus <- st_read("etl_aus.geojson")
```

We can see here that the ETL dataset is only composed by lines. Let's plot them to get a sense of how they look like: 

```{r}
plot(st_geometry(etl_aus))
```

The lines would correspond to the edges, however, the nodes are not present if such dataset would be represented as a network. This can be obtained by using some R coding, however to illustrate it on a higher scale, we will only look at data for Sidney.  

```{r}
## Getting the Sidney outline from OSM
library(osmdata)
sidneybb <- getbb('Sidney, Australia', format_out = 'sf_polygon')

## Intersecting the national ETL data to Sidney
etl_sidney <- etl_aus[sidneybb, op = st_intersects]

## Simplifying the dataset, to eliminate not used information
library(dplyr)
etl_sidney <- etl_sidney %>% select(Name)

## Plotting the result
plot(st_geometry(etl_sidney))
```

To concert the lines into a network, we would have to generate the edges and nodes, in a way that the start and end point of the lines are the nodes of the network. Nodes might repeat among edges, so we should look into unique IDs. We can write a helper function to do such a task:

```{r}
line2network <- function(x) {
  # The edges of the network are simply the linestrings from the sf object
  edges <- x

  ## Add a unique ID to each edge
  edges <- edges %>%
    mutate(edgeID = c(1:n()))
  
  # The nodes are the startpoints and endpoints of the linestrings
  # The function st_coordinates gets the coordinates of all the points of a line
  # The column L1 specifies to which line a set of point coordinates belongs
  # Filter start and endpoints by grouping by L1 and selecting first and last entry of each group
  # Then, assign a value of 0 to startpoints (source) and 1 to endpoints (target)
  nodes <- x %>%
    sf::st_coordinates() %>%
    as.data.frame() %>%
    group_by(.data$L1) %>%
    slice(c(1, n())) %>%
    ungroup() %>%
    mutate(startend = rep(c(0, 1), times = n()/2))
  
  # If lines share startpoint and/or endpoint, this point should be one single node
  # That is, duplicated points in the nodes data should have the same unique node ID
  # For this, group the nodes data by the combination (X, Y)
  # Then, retrieve group indices, that form unique IDs for each node
  node_ids <- nodes %>%
    group_by(.data$X, .data$Y) %>%
    group_indices()
  
  # Add this unique node ID as a column to the nodes data
  nodes <- nodes %>%
    mutate(nodeID = node_ids)
  
  # Add two columns to the edges data
  # One column represents the unique node ID of the startnode (source) of each edge
  # The other column represents the unique node ID of the endnode (target) of each edge
  sources <- nodes %>%
    filter(.data$startend == 0) %>%
    pull(.data$nodeID)
  
  targets <- nodes %>%
    filter(.data$startend == 1) %>%
    pull(.data$nodeID)
  
  edges <- edges %>%
    mutate(nodeID_source = sources, nodeID_target = targets)
  
  # The source and target node IDs are added to the edges data
  # Now, duplicate points can be removed from the nodes data
  # That is, each node will only occur once in the nodes data
  # Then, columns L1 and startend are not appropriate anymore and should be removed
  # Finally, convert the nodes data into an sf object with point geometry
  # The CRS of the nodes sf object should be the same as of the inputted sf object
  nodes <- nodes %>%
    distinct(.data$nodeID, .keep_all = TRUE) %>%
    select(-c(.data$L1, .data$startend)) %>%
    as.data.frame() %>%
    sf::st_as_sf(coords = c("X", "Y")) %>%
    sf::st_set_crs(sf::st_crs(x))
  
  # Finally, add a length column to the edges data
  # This column will represent the length in meters of each edge
  edges <- edges %>%
    mutate(length = sf::st_length(.data$geometry))
  
  net <- list(edges, nodes)
  
  setNames(net, c('edges','nodes'))
}
```

And then convert the data into a set of edges and nodes:

```{r}
etl_net <- line2network(etl_sidney)
etl_net
```

We can even see on the Name attribute that there is some sort of origin and destination: `Penrith to Warrimoo`, where Penrith would correspond to node 8 and Warrimo to node 11. 

Now we can plot both the edges and the nodes to see what we did, or even better use again tmap to view it interactively.

```{r}
library(tmap)
tmap_mode('view')

tm_shape(sidneybb) +
  tm_borders(col = 'red') +
  tm_shape(st_zm(etl_net$edges, drop = T)) +
  tm_lines(col = 'grey30') +
  tm_shape(etl_net$nodes) +
  tm_dots(col = 'orange')
```

